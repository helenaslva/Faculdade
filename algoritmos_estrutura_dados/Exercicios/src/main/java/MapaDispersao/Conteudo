‚ÄúCompactamos‚Äù a faixa de valores para utilizar uma faixa
menor.
‚Ä¢ Fun√ß√£o de dispers√£o ou fun√ß√£o de hash √© uma fun√ß√£o
matem√°tica que converte um n√∫mero compreendido numa
faixa de valores grande para uma faixa de valores menor
‚Äì O resultado desta fun√ß√£o √© ‚Äúvalor de hash‚Äù e corresponde ao √≠ndice do
vetor


Considerar que ao inv√©s de um
vetor de 10 mil elementos,
tenhamos apenas 16
elementos.
‚Ä¢ Podemos ‚Äúcompactar‚Äù com a
fun√ß√£o: Matricula % 16


Cada objeto armazenado na tabela de dispers√£o deve possuir
uma chave de busca que √© √∫nica para cada objeto

A chave de busca ou chave de pesquisa √© utilizada nas
opera√ß√µes de inclus√£o, exclus√£o e pesquisa

Para pesquisar um elemento na tabela de dispers√£o:
‚Äì Calcular o valor de hash da chave para identificar o √≠ndice do vetor
‚Äì Se o √≠ndice estiver vazio, o elemento n√£o foi adicionado
‚Ä¢ Para inserir um elemento na tabela de dispers√£o
‚Äì Calcular o valor de hash da chave para identificar o √≠ndice do vetor
‚Äì Inserir o elemento no √≠ndice calculado
‚Ä¢ Para excluir um elemento da tabela de dispers√£o
‚Äì Calcular o valor de hash da chave para identificar o √≠ndice do vetor
‚Äì Excluir o elemento no √≠ndice calculado
C

Ao comprimir uma faixa
de chaves com grande
intervalo numa faixa de
pequeno intervalo, n√£o
h√° garantias de que n√£o
haja duas chaves com o
mesmo √≠ndice do vetor

Ao calcular o valor de hash para um elemento e identificar
que a posi√ß√£o do vetor j√° est√° ocupada, afirmamos que
ocorreu uma colis√£o.
‚Ä¢ Para reduzir as colis√µes deve-se:
‚Äì Aumentar o tamanho do vetor e
‚Äì Criar um vetor cuja quantidade de elementos seja um n√∫mero primo


Fator de carga
‚Ä¢ √â a propor√ß√£o do n√∫mero de dados armazenados no
mapa sobre o tamanho total do vetor.
f= ùëÅ/ùëÄ
‚ñ™ N = quantidade de dados armazenados
‚ñ™ M = tamanho do vetor

Para minimizar colis√µes mas n√£o desperdi√ßar muito
espa√ßo, utiliza-se um fator de carga igual √† 0,75.


*** Tratamento de colis√µes por E ndere√ßamento separado****
Neste abordagem, o
vetor n√£o armazena
os dados, ao inv√©s
disso, mant√©m listas
encadeadas, para
armazenar os dados.



A chave de um item de dados √© convertida para o √≠ndice. O
elemento √© adicionado na lista encadeada daquele √≠ndice.
‚Äì N√£o h√° necessidade de buscar posi√ß√µes vazias no vetor prim√°rio, como
ocorre com o endere√ßamento aberto.

A pesquisa requer efetuar uma busca linear na lista
encadeada do √≠ndice calculado pela fun√ß√£o de dispers√£o


Algumas desvantagens:
‚Äì Baseiam-se em vetores
‚Ä¢ Dif√≠ceis de expandir
‚Äì Podem ter desempenho reduzido de forma significativa
‚Ä¢ Requer que o programador saiba antecipadamente a quantidade
aproximada de dados.
‚Äì N√£o h√° uma maneira conveniente de visitar os itens de
uma tabela de dispers√£o de forma ordenada



Chaves de busca do tipo texto
‚Ä¢ Pode-se atribuir um c√≥digo para cada caractere. Exemplo:
Exemplo: para a palavra ‚ÄúCASA‚Äù poderia ser
atribu√≠do:
C = 3
A = 1
S = 19
A = 1
3 + 1 + 19 + 1 = 24


Algoritmo: calcularHash(String texto)
int n ‚Üê size(texto) - 1;
h ‚Üê 0;
para c ‚Üê 0 at√© n fa√ßa
 caractere ‚Üê texto[c];
 codigo ‚Üê mapear(caractere);
 h ‚Üê h + (c√≥digo * 26 ^ c);
fim-para;
retornar h



Podem ser gerados n√∫meros muito grandes, causando
overflow



Fun√ß√£o de hash para string em Java
‚Ä¢ Em Java, o hashCode() para string √© calculado desta forma:
‚Ä¢ Exemplo:
 ‚ÄúCASA‚Äù
s[0]*31(n-1) + s[1]*31(n-2) + ... + s[n-1]*310
2061100

Fun√ß√£o de hash para string em Java
‚Ä¢ Utiliza-se o n√∫mero 31 pelas seguintes quest√µes:
‚Ä¢ Efici√™ncia em opera√ß√µes de bits: O n√∫mero 31 √© um n√∫mero primo baixo, o que significa que
tem poucos divisores.
‚Ä¢ Distribui√ß√£o de bits: O n√∫mero 31 tem uma propriedade interessante quando multiplicado
por um inteiro: ele pode ser expresso como (32 - 1), o que significa que √© equivalente a um
deslocamento de bits 5 bits para a esquerda (j√° que 32 √© 2 elevado √† 5¬™ pot√™ncia). Isso pode
ajudar a distribuir os bits de forma mais uniforme ao multiplicar e espalhar os bits dos
caracteres da String ao calcular o hash.
‚Ä¢ Evita multiplicadores menores: Escolher um multiplicador muito pequeno pode resultar em
colis√µes mais frequentes e uma distribui√ß√£o menos uniforme dos valores hash. O n√∫mero 31
√© pequeno o suficiente para manter a efici√™ncia computacional, mas grande o suficiente para
ajudar a reduzir as colis√µes.
‚Ä¢ Desempenho: O n√∫mero 31 oferece um bom equil√≠brio entre desempenho e distribui√ß√£o de
bits. Ele tem sido historicamente eficaz em produzir valores hash com poucas colis√µes e bom
desempenho em uma ampla gama de casos de uso.